#BlueJ class context
comment0.params=
comment0.target=UnDirectedGraph()
comment0.text=\r\n\ Creates\ an\ undirected\ graph\ that\ is\ a\ Hash\ Map\r\n
comment1.params=k
comment1.target=boolean\ AddNode(java.lang.Integer)
comment1.text=\r\n\ Adds\ a\ node\ with\ key\ k\r\n\ If\ the\ map\ already\ contains\ the\ key\ k,\ it\ returns\ false\r\n\ Otherwise,\ put\ a\ new\ entry\ into\ the\ map\ with\ key\ K\ and\ create\ a\ new\r\n\ UnDirectedGraphNode\ whose\ key\ is\ K\ and\ place\ that\ as\ the\ value\ and\ return\ true\r\n\ \r\n\ @param\ Integer\ K\ which\ is\ the\ key\ to\ the\ node\r\n\ \r\n\ @returns\ true\ if\ the\ node\ has\ been\ successfully\ added\ or\ false\ if\r\n\ it\ has\ not\ been\ successfully\ added\r\n
comment2.params=k1\ k2\ w
comment2.target=boolean\ AddEdge(int,\ int,\ double)
comment2.text=\r\n\ Adds\ an\ edge\ from\ the\ node\ with\ key\ k1\ to\ the\ node\ with\ key\ k2.\ \r\n\ The\ edge\ has\ weight\ w.\r\n\ If\ the\ map\ does\ not\ contain\ either\ of\ the\ Nodes,\ return\ false\r\n\ Otherwise,\ get\ the\ adjancy\ lists\ of\ both\ nodes\ and\ add\ a\ new\ entry\ to\r\n\ each\ of\ their\ adjancy\ lists\ whcih\ is\ a\ new\ edge\ that\ points\ to\ where\ the\ \r\n\ edge\ is\ connecting\ to\ and\ the\ weight,\ return\ true\r\n\ \r\n\ @param\ Two\ Nodes\ k1\ and\ k2\ which\ will\ be\ connected\ with\ this\ edge\ and\ the\ \r\n\ weight\ of\ their\ edge\ w\r\n\ \r\n\ @returns\ true\ if\ the\ edge\ is\ successfully\ added\ or\ false\ if\ the\ edge\ has\r\n\ not\ been\ successfully\ added\r\n
comment3.params=start\ end
comment3.target=double\ getEdge(int,\ int)
comment3.text=\r\n\ A\ method\ that\ returns\ the\ edge\ weight\ between\ two\ nodes.\ \r\n\ \r\n\ This\ method\ extracts\ the\ adjacency\ list\ of\ the\ start\ node\ and\ stores\ that\ into\ a\ Linked\ List.\ \r\n\ For\ every\ edge\ in\ the\ adjancency\ list\ of\ the\ start\ node,\ get\ the\ node\ that\ that\ edge\ is\ going\ to.\ \r\n\ Note\ -\ The\ UnDirectedEdge\ inner\ class\ is\ created\ with\ the\ node\ the\ ede\ is\ going\ to\ and\ the\ weight\ \r\n\ of\ the\ weight.\ \r\n\ If\ the\ node\ that\ the\ edge\ is\ going\ to\ matches\ the\ node\ that\ is\ the\ end\ node,\ return\ the\ weight\ of\ that\ edge.\r\n\ If\ the\ nodes\ do\ not\ match\ up,\ check\ the\ next\ edge.\ \r\n\ \r\n\ @return\ The\ double\ weight\ between\ two\ Nodes\r\n\ @param\ The\ integer\ references\ of\ two\ Nodes\ whose\ edge\ weight\ you\ are\ looking\ for.\r\n
comment4.params=k1\ k2
comment4.target=java.util.ArrayList\ findShortestPath(int,\ int)
comment4.text=\r\n\ Dijkstra's\ algorithm\ modified\ to\ return\ an\ ArrayList\ of\ the\ path\ and\ to\ fit\r\n\ to\ the\ vode\r\n\ \r\n\ Creates\ a\ Priority\ Queue\ which\ stores\ Path\ objects\r\n\ Retrieves\ the\ start\ and\ end\ nodes\ from\ the\ Map\ and\ stores\ them\ into\ variables\r\n\ If\ the\ start\ node\ is\ not\ in\ the\ map,\ throw\ an\ exception.\ \r\n\ Otherwise,\ clear\ all\ the\ nodes\ connections\r\n\ Adds\ a\ Path\ object\ to\ the\ priority\ queue\ with\ start\ node\ and\ 0\ as\ the\ weight\ because\r\n\ to\ go\ from\ the\ start\ node\ to\ the\ start\ node,\ that\ is\ a\ cost\ of\ 0\ since\ you\ are\ already\r\n\ at\ the\ node\r\n\ Creates\ a\ integer\ variable\ which\ is\ equal\ to\ 0\r\n\ While\ the\ priority\ queue\ is\ not\ empty\ and\ the\ amount\ of\ nodes\ seen\ is\ less\ than\ the\ \r\n\ amount\ of\ nodes\ in\ the\ vertex\ map...\r\n\ The\ path\ vrec\ removes\ a\ Path\ objecy\ from\ the\ priority\ queue\r\n\ If\ the\ removed\ vrec\ is\ the\ end\ node\ then\ break\ from\ the\ while\ look\ and\ there\ is\ only\r\n\ one\ path\ between\ the\ two\ nodes\r\n\ If\ not,\ the\ Node\ that\ vrec\ connects\ to\ is\ stored\ in\ variable\ v\r\n\ Only\ continue\ within\ the\ while\ loop\ if\ v.scratch\ is\ not\ 0\r\n\ Make\ v.scratch\ equal\ to\ 1\ and\ equal\ the\ number\ of\ nodes\ seen\ by\ 1\r\n\ For\ every\ UnDirectedEdge\ in\ vs\ adjacency\ list...\r\n\ Make\ UnDirectedGraphNode\ w\ equal\ to\ the\ Node\ that\ edge\ is\ going\ to\r\n\ MAke\ cvw\ equal\ to\ the\ edge\ cost\ \r\n\ If\ the\ distance\ of\ w\ is\ greater\ than\ the\ distance\ of\ v\ +\ the\ cost\ of\ the\ edge\r\n\ then\ the\ distance\ of\ becomes\ becomes\ equal\ to\ the\ distance\ of\ v\ plus\ cvw\ and\ ws\r\n\ previous\ is\ v\ and\ you\ add\ a\ new\ Path\ objecy\ to\ the\ priorirt\ queue\ of\ w\ and\ the\ w\ distance\r\n\ Break\ out\ of\ the\ if\ loop\ and\ complete\ the\ while\ loop\ until\ all\ nodes\ have\ been\ seen\r\n\ Stores\ all\ the\ nodes\ in\ an\ array\ list\ and\ then\ reveres\ the\ array\ list\ to\ get\ the\r\n\ proper\ sequence\ \r\n\ \r\n\ @param\ The\ start\ node\ k1\ and\ the\ end\ node\ k2\ in\ whcih\ you\ want\ to\ find\r\n\ the\ shorted\ path\ between\r\n\ @return\ The\ ArrayList\ that\ contains\ the\ reference\ to\ the\ nodes\ that\ form\ the\ shortest\ path\r\n\ @author\ Dijkstra\r\n\ @version\ The\ algorithm\ in\ Mark\ Allen\ Weiss's\ book\r\n
comment5.params=
comment5.target=void\ clearAll()
comment5.text=\r\n\ A\ method\ that\ for\ every\ Node\ in\ the\ vertex\ map,\ all\ variables\ are\ reset\r\n
numComments=6
